---
title : Lecture 06: Hash Tables
author: vector
source: https://15445.courses.cs.cmu.edu/fall2020/notes/06-hashtables.pdf
---

# Lecture 06: Hash Tables

## 1 Data Structures

DBMS内部会用各种数据结构来维护系统内部的各个部分。比如：

- 内部的元数据：这些数据记录着数据库系统的状态。如：页表、页目录等。
- 存储的数据：数据结构也会用来存储数据库中的的数据。
- 临时的数据结构：DBMS为了加快query的执行速度，会建立一些临时性的数据结构。比如join时的哈希表。
- 表索引：用来帮助更容易找到特定记录的辅助性数据结构。

设计上要考虑两个东西来决定在DBMS中使用哪种数据结构：

- 数据是如何组织的：我们要搞清楚，为了更高效的访问数据，我们要如何存、存什么？
- 并发：我们还要考虑到如何在不出问题的情况下让多个线程同时访问数据结构。

## 2 哈希表

哈希表就是一个可以把*键*映射到*值*的关联性（key-value associative）数组。它可以提供`O(1)`的平均时间复杂度（最坏情况`O(n)`），和`O(n)`的空间复杂度。注意即使是`O(1)`的平均时间复杂度，常数因子的优化也是真实世界中非常需要考虑的。

哈希表的实现分为两个部分：

- 哈希函数：哈希函数把取值范围比较大的键映射到一个小范围的域中。可以用它来计算出索引，进而索引到数组中。我们需要在处理速度和冲突率中进行取舍，最合适的设计在中间位置。
  在一个极端，如果哈希函数只会返回常数，这当然会很快，但是每一个键都是冲突的。
  另一个极端，如果哈希函数必要完美，没有冲突，它就会花很长时间来计算。
- 哈希模式：就是处理哈希冲突的方法。此时我们需要在分配大的哈希表来减少冲突，还是在冲突发生时多执行一些指令之间进行取舍。

## 3 哈希函数

哈希函数接收一个*键*作为参数，返回这个*键*对应的整数表示。函数的输出时唯一的，即对于相同的输入，总会产生一样的输出。

DBMS不会使用加密型哈希函数（如SHA-256），因为不需要。这些函数主要是在DBMS内部（In-memory）使用，因此信息不会泄漏到系统外部（因为这些数据不是durable的）。

总体上来说，我们只关心哈希函数的速度和冲突率。目前最棒的哈希函数就是来自Facebook的`XXHash3`。

## 4 静态哈希方法

静态哈希模式的哈希表大小是固定的。这就意味着如果DBMS用光了哈希表的所有位置时，哈希表就要重建一个更大的哈希表，这个代价非常大。一般来说新的哈希表是原来哈希表的两倍大。

为了减少不必要的比较，减少哈希冲突很重要。一般来说，我们会使用预期大小的两倍作为哈希表的大小。

除此之外，还有现实中一般不成立的假设：

1. 元素个数提前已知
2. 键都不一样
3. 存在一个完美哈希函数（不同的键不冲突）

因此，我们需要恰当地选择哈希函数和哈希模式。

### 4.1 linear probe hashing

linear probe hashing 是说在哈希冲突发生时，一直往后看，如果找到就插入。如果没找到（回到原位置），那就扩容。

### 4.2 robin hood hashing

robin hood 是中世纪英国一个民间故事中的主角，他是一个劫富济贫的侠盗。本方法和linear probe hashing 类似，但是多了两个概念。在介绍这两个概念之前，我们先定义一个词，原位置：指经过哈希后得到的索引指向的位置。

- rich key：在一次比较中，离原位置较近的键。
- pool key：相应地，离原位置比较远的键。

然后在linear probe hashing基础上遵循“劫富济贫”的原则，对于每一个想要占用的位置，如果待插入的键键比该位置上已存在的键更“穷”，则占有该位置。相应地，换该位置上比较“富”的键继续往后看要插在哪里。

### 4.3 Cuckoo hashing

起名源于布谷鸟的习性——鸠占鹊巢，Cuckoo就是布谷鸟。鸠，即是布谷鸟，也即杜鹃。

一般有两个哈希函数（也可以多个），其实是一个哈希函数，但是有两个种子（seed），还有两个哈希表。对于某一个键来说，在经过 Hash<sub>1</sub>(key)之后：

- 如果在table<sub>1</sub>中，这个没有被占：那就直接放入其中。
- 如果被占了，那就进行 Hash<sub>2</sub>(key)：如果在table<sub>2</sub>中没有被占，那就放入其中。
- 如果还是被占了，则进行“鸠占鹊巢”，鹊就只能再找其它巢：将该键放入该位置，同时将原键取出。
  - 取出后对该取出的键进行 Hash<sub>1</sub>(key’)，看能不能把它放到table<sub>1</sub>中。
  - 如果可以，那就放。
  - 如果不行，那就按如上步骤一直“鸠占鹊巢”即可。
- 如果找了一圈还没找到，那说明该扩容了。扩容即可。



## 5 Dynamic hashing schemes

静态哈希方法要求DBMS事先知道待存储元素的数量，否则它就需要在需要的时候重建整个表。

动态哈希方法则可以按需变换大小，而不需要重建整个表。动态哈希方法以要么最大化读、要么最大化写为代价的方式来改变大小。

### 5.1 chained hashing

这种是最常见的动态哈希方法。DBMS会给哈希表中每一格都维护一个链式桶。哈希到相同位置的键都插到那个格子的链式桶中。

### 5.2 Extendible hashing

chained hashing的增强版。这种方法允许多个格子映射到同一个链式桶。核心思想就是通过分裂并增加需要检查的比特位数来使得链式桶重新平衡。

- DBMS维护着一个全局比特位数，以及给每一个桶都维护这一个本地比特位数。
- 当一个桶满了之后，DBMS就会让这个桶分裂，增加这个桶的本地比特位数（如果和全局比特位数一样，那就全局和这个本地比特位数一起增加），然后新的位数重新分配这个桶中的元素，并让哈希表中新增加的格子指向正确的位置。

如下图所示：

<div style="text-align:center"><img src="./assets/ExtendibleHashing.svg"></div>

### 5.3 Linear Hashing

与之前不一样，Linear Hashing在桶发生溢出时并不是分裂溢出的桶，而是分裂`split pointer`指向的桶。溢出的标准取决于具体实现。

- 当有桶溢出时，通过增加一个格子来分裂`split pointer`指向的桶，并新建一个哈希函数。
- 如果哈希函数映射到`split pointer`之前的格子，说明它的格子分裂过，那就使用新建的哈希函数。
- 当`split pointer`到最后一个格子后，删除原来的哈希函数并用一个新的替换它。

