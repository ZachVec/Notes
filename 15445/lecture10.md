---
title : Lecture 10: Sorting & Aggregation Algorithms
author: vector
source: https://15445.courses.cs.cmu.edu/fall2019/notes/10-sorting.pdf
---

# Lecture 10: Sorting & Aggregation Algorithms

## 1 排序

由于在关系模型中的数据是无序的，而排序又在 `ORDER BY`、`GROUP BY`、`JOIN` 及 `DISTINCT` 操作符中可能被用到，所以我们需要排序。

我们可以通过扫描 聚合B+ 树的叶结点来加速排序。但在非聚合 B+ 树中这样做会导致大量的磁盘随机读取，所以不建议在非聚合 B+ 树中不建议使用。

如果待排序的数据能够全部放到内存中，那 DBMS 直接使用标准排序算法即可，如快排。如果无法全部放入，则 DBMS 需要使用外部排序。外部排序能够按需从硬盘取用数据，且相较于随机 I/O 更偏向于顺序 I/O。

## 2 外部归并排序

分治排序算法把数据集分散到不同*组*（runs）中，然后分别排序。它可以把不同*组*(（runs）的数据按需写到硬盘，然后一次性把它们读到内存。分为两个阶段：

**Phase #1 – 排序**: 每次从内存中读取一小块，排序，然后写回内存。

**Phase #2 – 归并**: 把很多已经有序的小块子文件（由于在硬盘上，所以叫做文件）组合成一个单独的大文件。

> 在接下来的叙述中，假设缓冲池大小为 B 页，共有 N 页数据待排序。

### 双路归并排序

1. Pass #0：每次读取 B 页连续的数据到内存。排序，然后把它们写回内存。有序页的集合叫做*组*（run）。
2. Pass #1,2,3...：递归地将一对 *组* 合并成两倍长的组。

Pass 的次数：1 + ⌈log<sub>2</sub>N⌉

总的 I/O 次数：2 * (# of Passes)

### 一般（K-路）归并排序

1. Pass #0：用 B 个缓冲页，产生了 N / B 个大小为 B 的组。
2. Pass #1,2,3...：递归地合并 B - 1 个组（有一个组用来输出，所以一次只能合并 B - 1 个组）

Pass 的次数：1 +  ⌈log<sub>B-1</sub>⌈N / B⌉⌉

总共的 I/O 次数：2N * (# of passes)

### 双缓冲忧患 (预取)

我们可以在处理这一轮的数据时，把下一轮的数据在后台取好，然后放到缓冲池中。这可以通过持续使用（而不是断断续续使用）来减少等待 I / O 的时间。

## 3 聚合

在 Query Plan 中的聚合算符会使一条或多条数据变成一个标量值（就是由多列变成一列）。有两种方法来实现聚合：排序、哈希。

### 排序

DBMS 首先用 `GROUP BY` 的键排序。如果数据能放进缓冲池，就用内存内的排序算法（如快排），否则就用外部归并排序。

然后 DBMS 会通过顺序扫描有序数据来计算出聚合的结果，最后的数据关于键有序。

### 哈希

在计算聚合时，哈希比排序需要更少的计算量。DBMS 会在它扫描整个表的时候产生一个临时哈希表。对于每条数据，检查它的键是否已经存在于哈希表中，然后进行对应的修改。

如果哈希表太大了，放不进内存，那么 DBMS 就得把它写到硬盘：

- Phase #1 - 分散：用哈希函数 H<sub>1</sub> （以键为输入）把数据分散到不同的部分。当写满时就写至硬盘。
- Phase #2 - 再哈希：对于硬盘中的每一部分，把它的页读入内存，然后基于哈希函数 H<sub>2</sub> （H<sub>1</sub> ≠ H<sub>2</sub>）建立内存中的哈希表。然后遍历哈希表中的每一个桶，计算所有哈希值一样的数据的聚合。这里假设每一部分都能放到内存。

在 *Phase #1 - 分散* 阶段，如果缓冲池总共有 B 页，则有 B-1 页分给 B-1 个部分，还有一页用来输入。

在 *Phase #2 - 再哈希* 阶段，DBMS 可以存储 `GroupByKey` → `RunningValue` 对来计算聚合。`RunningValue` 的内存取决于聚合函数。如果要在哈希表中插入新的数据：

- 如果它与某个 `GroupByKey` 匹配上了，那就更新 `GroupByKey` 对应的 `RunningValue`。
- 否则就插入新的 `GroupByKey` → `RunningValue` 对。

> 这里的 `GroupByKey` 就是 SQL 中 `Group By` 后跟的键。如果没有 `Group By` 那就所有的为一组，直接聚合就行。这里的 `RunningValue` 指的是为了计算出最终聚合的结果所需要维护的数据。比如，
>
> | `Aggregation` |  `RunningValue`  |
> | :-----------: | :--------------: |
> |     `AVG`     | (`COUNT`, `SUM`) |
> |    `COUNT`    |     `COUNT`      |
> |     `SUM`     |      `SUM`       |
> |     `MAX`     |      `MAX`       |
> |     `MIN`     |      `MIN`       |

